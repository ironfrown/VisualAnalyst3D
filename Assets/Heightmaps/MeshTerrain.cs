//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Linq;
using UnityEngine;
public class MeshTerrain
{
	ColorSpectrumObj spectrum;
	
	protected Texture2D heightMap;
	protected Texture2D colorMap;
	protected double minX, minZ, maxX, maxZ;
	
	protected double lowerBound, upperBound;
	protected String filename;
	double hmapWidth;
	double hmapHeight;
	double cmapWidth;
	double cmapHeight;
	
	public static int HILLS = 0; 
	public static int PEAKS = 1;

	// Variables Holder
	Variables Vars;
	
	/// <summary>
	/// Initializes a new instance of the <see cref="HeightmapGenerator"/> class.
	/// </summary>
	/// <param name="data">Data with each object containing the following structure: 
	/// [ peak_height, peak_X, peak_Y ]</param>
	/// <param name="tWidth">T width.</param>
	/// <param name="tHeight">T height.</param>
	/// <param name="maxRadius">Max radius.</param>
	/// 
	/*public HeightmapGenerator (List<double[]> data, int bitmapWidth, int bitmapHeight, double maxRadius)*/
	public MeshTerrain (Variables Vars, String filename,
	                    double minX, double minZ, double maxX, double maxZ)
	{
		this.Vars = Vars;
		this.filename = filename;
		this.minX = minZ;
		this.minZ = maxX;
		this.maxX = maxZ;
		this.maxZ = minX;
	}
	
//	public virtual Texture2D GetHeightmap(double bWidth, double bHeight){
//		List<double[]> data = GenerateData();
//		
//		this.hmapWidth = bWidth;
//		this.hmapHeight = bHeight;
//		heightMap = new Texture2D((int)bWidth, (int)bHeight);
//		FillInColor(Color.black);
//		
//		double[] bnds= GetBounds(data);
//		lowerBound = bnds[0];
//		upperBound = bnds[1];
//		
//		
//		CreateHeightMap(data);
////		SaveToDisk();
//		return heightMap;
//	}

	/// <summary>
	/// Gets the height and color map.
	/// </summary>
	/// <returns>The height and color map in the Texture2D array with form {heightMap, colorMap}.</returns>
	/// <param name="heightMapWidth">Height map width.</param>
	/// <param name="heightMapHeight">Height map height.</param>
	/// <param name="colorMapWidth">Color map width.</param>
	/// <param name="colorMapHeight">Color map height.</param>
	/// <param name="spectrum">Spectrum.</param>
	public virtual Texture2D GetHeightmap(double heightMapWidth,
	                                                double heightMapHeight,
	                                                ColorSpectrumObj spectrum){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = 0d;//bnds[0];// - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = bnds[1];

		this.spectrum = spectrum;
		this.hmapWidth = heightMapWidth;
		this.hmapHeight = heightMapHeight;
//		this.cmapWidth = colorMapWidth;
//		this.cmapHeight = colorMapHeight;
		heightMap = new Texture2D((int)hmapWidth, (int)hmapHeight);
//		colorMap = new Texture2D((int)cmapWidth, (int)cmapHeight);
		FillInColor(heightMap,Color.black);
//		FillInColor(colorMap,Color.black);

		CreateHeightMap(dataHandler.GetData());
//		CreateColorMap(dataHandler.GetData());

//		return new Texture2D[]{heightMap, colorMap};
		return heightMap;
	}

	public virtual Texture2D GetColormap(double colorMapWidth,
	                                     double colorMapHeight,
	                                     ColorSpectrumObj spectrum){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = bnds[1];
		
		this.spectrum = spectrum;
		this.cmapWidth = colorMapWidth;
		this.cmapHeight = colorMapHeight;
		colorMap = new Texture2D((int)cmapWidth, (int)cmapHeight);
		FillInColor(colorMap,Color.black);
		
		CreateColorMap(dataHandler.GetData());
		
		return colorMap;
	}

	public virtual Texture2D GetColormap(double colorMapWidth,
	                                     double colorMapHeight,
	                                     ColorSpectrumObj spectrum,
	                                     double lower,
	                                     double upper){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = lower;//bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = upper;//bnds[1];
		
		this.spectrum = spectrum;
		this.cmapWidth = colorMapWidth;
		this.cmapHeight = colorMapHeight;
		colorMap = new Texture2D((int)cmapWidth, (int)cmapHeight);
		FillInColor(colorMap,Color.black);
		
		CreateColorMap(dataHandler.GetData());
		
		return colorMap;
	}
	
	protected void FillInColor(Texture2D tx, Color c){
		for(int i = 0; i < tx.width; i++) {
			for(int j = 0; j < tx.height; j++) {
				tx.SetPixel(i,j, c);
			}
		}
	}

	public virtual void SaveHeightToDisk(Texture2D tx) {
		byte[] bytes = tx.EncodeToPNG();
		File.WriteAllBytes(Application.dataPath + "/Heightmaps/Images/GA_" + Vars.TERRAIN_NAME + ".png", bytes);
	}

	public virtual void SaveColorToDisk(Texture2D tx) {
		byte[] bytes = tx.EncodeToPNG();
		File.WriteAllBytes(Application.dataPath + "/Heightmaps/Images/GA_Color_" + Vars.TERRAIN_NAME + ".png", bytes);
	}

	
	double[,] map;
	bool[,] map_pump;
	bool[,] map_nonzero;
	bool[,] map_nonzero_temp;
	double[,] map_temp;

	/// <summary>
	/// Creates the height map.
	/// </summary>  
	/// <param name="data">Data with each object containing the following structure:    
	/// [ peak_height, peak_X, peak_Y ]
	/// </param> 
	protected void CreateHeightMap(List<double[]> data){
		/// Parallel Processing
		int numCores = SystemInfo.processorCount;

		// convert list of double[] to list of Vector3's and sort it. 
		List<Vector3> points = new List<Vector3>();
		for(int i=0; i<data.Count; i++){
			double[] t = data[i];
			points.Add(new Vector3((float)t[0], (float)t[1], (float)t[2]));
		}

		//Genetic Algorithm for mesh construction
		map = new double[(int)hmapWidth, (int)hmapHeight];
		map_pump = new bool[(int)hmapWidth, (int)hmapHeight];
		map_nonzero = new bool[(int)hmapWidth, (int)hmapHeight];
		map_nonzero_temp = new bool[(int)hmapWidth, (int)hmapHeight];
		map_temp = new double[(int)hmapWidth, (int)hmapHeight];
		for(int i=0; i<points.Count; i++){
			Vector3 p = points[i];
			int x = (int)(p.x*(hmapWidth-1));
			int z = (int)(p.z*(hmapHeight-1));
			map[x, z] = p.y;
			map_pump[x, z] = true;
			heightMap.SetPixel(x,z,GrayscaleFromHeight(p.y, upperBound, lowerBound));
		}

		for(int a=0; a<hmapWidth; a++){
			for (int b=0; b<hmapHeight; b++){
				if(!map_pump[a,b])
					map[a,b] = 0f;
				map_nonzero[a,b] = true;
			}
		}
		heightMap.Apply();

		Array.Copy (map, map_temp,map.Length);
		Array.Copy (map_nonzero, map_nonzero_temp, map_nonzero.Length);
		int iterationMax = Vars.GENETIC_MAX_ITERATION;	//Variable in CSV
		//BEGIN GENETIC ALGORITHM 
		for(int i=0; i<iterationMax; i++){
			for(int n=0; n<numCores; n++){
				System.Threading.ParameterizedThreadStart pts = new System.Threading.ParameterizedThreadStart(Foo);
				System.Threading.Thread worker = new System.Threading.Thread(pts);
				worker.Start(new int[]{(int)(hmapHeight/numCores)*n, (int)((hmapHeight/numCores)*(n+1))});
			}
//			Foo (new int[]{0,(int)hmapHeight});
			Array.Copy (map_temp, map, map_temp.Length);
			Array.Copy (map_nonzero_temp, map_nonzero, map_nonzero_temp.Length);
			//if(i == 0 || i == iterationMax-1){
			//}
		}
		heightMap.Apply();

		// adjust pumps 
		for(int i=0; i<Vars.GENETIC_SMOOTH_ITERATION; i++){
			for(int n=0; n<numCores; n++){
				System.Threading.ParameterizedThreadStart pts = new System.Threading.ParameterizedThreadStart(Bar);
				System.Threading.Thread worker = new System.Threading.Thread(pts);
				worker.Start(new int[]{(int)(hmapHeight/numCores)*n, (int)((hmapHeight/numCores)*(n+1))});
			}
			Array.Copy (map_temp, map, map_temp.Length);
			Array.Copy (map_nonzero_temp, map_nonzero, map_nonzero_temp.Length);
		}
		heightMap.Apply(); 

		// Scale values back to original bounds:
		double minC = map.Cast<double>().Min(), maxC = map.Cast<double>().Max ();
		for(int x=0; x<hmapWidth; x++){
			for (int z=0; z<hmapHeight; z++){
				heightMap.SetPixel(x,z,GrayscaleFromHeight(map[x, z], maxC, minC)); 
			}
		}

		heightMap.Apply(); 
		SaveHeightToDisk(heightMap);

		// Vector Resolute mesh algorithm **WIP
		/* 
		double it = (maxX - minX)/Vars.ITERATION_NUMBER;
		for(double x=minX; x<maxX; x+=it){
			for(double z=minZ; x<maxZ; z+=it){
				Vector3 N = new Vector3(x, 0, z);
				IOrderedEnumerable<Vector3> ioe = points.OrderBy(f => Vector3.Distance(N, f));
				// calculate the vector resolute of O->N {where N is (x,0,z)} in the direction of A->B
				Vector3 A = ioe.ElementAt(0);
				Vector3 B = ioe.ElementAt(1);
				Vector3 C = ioe.ElementAt(2);
				
				Vector3 NinB = Vector3.Dot(N, B.normalized)*B.normalized;
				Vector3 AinB = Vector3.Dot(A, B.normalized)*B.normalized;
				double propNtoAB = (NinB - AinB).magnitude/(B-A).magnitude;

				Vector3 NinC = Vector3.Dot(N, C.normalized)*C.normalized;
				Vector3 AinC = Vector3.Dot(A, C.normalized)*C.normalized;
				double propNtoAC = (NinC - AinC).magnitude/(C-A).magnitude;

				Vector3 temp = Vector3.Lerp(A, B, propNtoAB);
				Vector3 temp2 = Vector3.Lerp(A, C, propNtoAC);
				Vector3 pos = Vector3.Lerp
			}
		}*/
	}

	private void Bar(object rangeArray){
		int start = ((int[])rangeArray)[0];
		int stop = ((int[])rangeArray)[1];
		for(int x=0; x<hmapWidth; x++){
			for (int z=0; z<hmapHeight; z++){
				double avg = 0f;
				double div = 0f;
				if(x > 0){
					avg += map[x-1, z];
					div += map_nonzero[x-1, z]? 1 : 0;
				}if(z > 0){
					avg += map[x, z-1];
					div += map_nonzero[x, z-1]? 1 : 0;
				}if(x < hmapWidth-1){
					avg += map[x+1, z];
					div += map_nonzero[x+1, z]? 1 : 0;
				}if( z < hmapHeight-1){
					avg += map[x, z+1];
					div += map_nonzero[x, z+1]? 1 : 0;
				}if(x > 0 && z > 0){
					avg += map[x-1, z-1];
					div += map_nonzero[x-1, z-1]? 1 : 0;
				}if(x < hmapWidth-1 && z > 0){
					avg += map[x+1, z-1];
					div += map_nonzero[x+1, z-1]? 1 : 0;
				}if(x > 0 && z < hmapHeight-1){
					avg += map[x-1, z+1];
					div += map_nonzero[x-1, z+1]? 1 : 0;
				}if(x < hmapWidth-1 && z < hmapHeight-1){
					avg += map[x+1, z+1];
					div += map_nonzero[x+1, z+1]? 1 : 0;
				}
				
				avg = (div != 0) ? avg/div : 0;
				map_temp[x,z] = avg;
				map_nonzero_temp[x, z] = (avg != 0) ? true : false;
				//					heightMap.SetPixel(x,z,GrayscaleFromHeight(avg, upperBound, lowerBound)); // Put outside loop
			}
		}
	}

	private void Foo(object rangeArray){
		int start = ((int[])rangeArray)[0];
		int stop = ((int[])rangeArray)[1];
		for(int x=0; x<hmapWidth; x++){
			for(int z=start; z<stop; z++){
				if(!map_pump[x,z]){
					double avg = 0f;
					double div = 0f;
					if(x > 0){
						avg += map[x-1, z];
						div += map_nonzero[x-1, z]? 1 : 0;
					}if(z > 0){
						avg += map[x, z-1];
						div += map_nonzero[x, z-1]? 1 : 0;
					}if(x < hmapWidth-1){
						avg += map[x+1, z];
						div += map_nonzero[x+1, z]? 1 : 0;
					}if( z < hmapHeight-1){
						avg += map[x, z+1];
						div += map_nonzero[x, z+1]? 1 : 0;
					}if(x > 0 && z > 0){
						avg += map[x-1, z-1];
						div += map_nonzero[x-1, z-1]? 1 : 0;
					}if(x < hmapWidth-1 && z > 0){
						avg += map[x+1, z-1];
						div += map_nonzero[x+1, z-1]? 1 : 0;
					}if(x > 0 && z < hmapHeight-1){
						avg += map[x-1, z+1];
						div += map_nonzero[x-1, z+1]? 1 : 0;
					}if(x < hmapWidth-1 && z < hmapHeight-1){
						avg += map[x+1, z+1];
						div += map_nonzero[x+1, z+1]? 1 : 0;
					}
					
					avg = (div != 0) ? avg/div : 0;
					map_temp[x,z] = avg;
					map_nonzero_temp[x, z] = (avg != 0) ? true : false;
//					heightMap.SetPixel(x,z,GrayscaleFromHeight(avg, upperBound, lowerBound)); // Put outside loop 
				}
			}
		}
	}

	protected void CreateColorMap(List<double[]> data){
		// convert list of double[] to list of Vector3's and sort it. 
		List<Vector3> points = new List<Vector3>();
		for(int i=0; i<data.Count; i++){
			double[] t = data[i];
			points.Add(new Vector3((float)t[0], (float)t[1], (float)t[2]));
		}
		
		//Genetic Algorithm for mesh construction 
		double[,] map = new double[(int)cmapWidth, (int)cmapHeight];
		bool[,] map_pump = new bool[(int)cmapWidth, (int)cmapHeight];
		bool[,] map_nonzero = new bool[(int)cmapWidth, (int)cmapHeight];
		for(int i=0; i<points.Count; i++){
			Vector3 p = points[i];
			int x = (int)(p.x*(cmapWidth-1));
			int z = (int)(p.z*(cmapHeight-1));
			map[x, z] = p.y;
			map_pump[x, z] = true;
			map_nonzero[x,z] = true;
			colorMap.SetPixel(x,z,ColorFromHeight(p.y, upperBound, lowerBound));
		}
		
		for(int a=0; a<cmapWidth; a++){
			for (int b=0; b<cmapHeight; b++){
				if(!map_pump[a,b])
					map[a,b] = 0f;
				map_nonzero[a,b] = true;
			}
		} 
		colorMap.Apply();
		
		double[,] map_temp = new double[(int)cmapWidth, (int)cmapWidth];
		bool[,] map_nonzero_temp = new bool[(int)cmapWidth, (int)cmapWidth];
		Array.Copy (map, map_temp,map.Length);
		Array.Copy (map_nonzero, map_nonzero_temp, map_nonzero.Length);
		int iterationMax = Vars.GENETIC_MAX_ITERATION;
		//BEGIN GENETIC ALGORITHM
		for(int i=0; i<iterationMax; i++){
			for(int x=0; x<cmapWidth; x++){
				for(int z=0; z<cmapHeight; z++){
					if(!map_pump[x,z]){
						double avg = 0f;
						double div = 0f;
						if(x > 0){
							avg += map[x-1, z];
							div += map_nonzero[x-1, z]? 1 : 0;
						}if(z > 0){
							avg += map[x, z-1];
							div += map_nonzero[x, z-1]? 1 : 0;
						}if(x < cmapWidth-1){
							avg += map[x+1, z];
							div += map_nonzero[x+1, z]? 1 : 0;
						}if( z < cmapHeight-1){
							avg += map[x, z+1];
							div += map_nonzero[x, z+1]? 1 : 0;
						}if(x > 0 && z > 0){
							avg += map[x-1, z-1];
							div += map_nonzero[x-1, z-1]? 1 : 0;
						}if(x < cmapWidth-1 && z > 0){
							avg += map[x+1, z-1];
							div += map_nonzero[x+1, z-1]? 1 : 0;
						}if(x > 0 && z < cmapHeight-1){
							avg += map[x-1, z+1];
							div += map_nonzero[x-1, z+1]? 1 : 0;
						}if(x < cmapWidth-1 && z < cmapHeight-1){
							avg += map[x+1, z+1];
							div += map_nonzero[x+1, z+1]? 1 : 0;
						}
						
						avg = (div != 0) ? avg/div : 0;
						map_temp[x,z] = avg;
						map_nonzero_temp[x, z] = (avg != 0) ? true : false;
						colorMap.SetPixel(x,z,ColorFromHeight(avg, upperBound, lowerBound));  
					}
				}
			}
			Array.Copy (map_temp, map, map_temp.Length);
			Array.Copy (map_nonzero_temp, map_nonzero, map_nonzero_temp.Length);
		}
		colorMap.Apply();
		// adjust pumps 
		for(int i=0; i<Vars.GENETIC_SMOOTH_ITERATION; i++){
			for(int x=0; x<cmapWidth; x++){
				for (int z=0; z<cmapHeight; z++){
					double avg = 0f;
					double div = 0f;
					if(x > 0){
						avg += map[x-1, z];
						div += map_nonzero[x-1, z]? 1 : 0;
					}if(z > 0){
						avg += map[x, z-1];
						div += map_nonzero[x, z-1]? 1 : 0;
					}if(x < cmapWidth-1){
						avg += map[x+1, z];
						div += map_nonzero[x+1, z]? 1 : 0;
					}if( z < cmapHeight-1){
						avg += map[x, z+1];
						div += map_nonzero[x, z+1]? 1 : 0;
					}if(x > 0 && z > 0){
						avg += map[x-1, z-1];
						div += map_nonzero[x-1, z-1]? 1 : 0;
					}if(x < cmapWidth-1 && z > 0){
						avg += map[x+1, z-1];
						div += map_nonzero[x+1, z-1]? 1 : 0;
					}if(x > 0 && z < cmapHeight-1){
						avg += map[x-1, z+1];
						div += map_nonzero[x-1, z+1]? 1 : 0;
					}if(x < cmapWidth-1 && z < cmapHeight-1){
						avg += map[x+1, z+1];
						div += map_nonzero[x+1, z+1]? 1 : 0;
					}
					
					avg = (div != 0) ? avg/div : 0;
					map_temp[x,z] = avg;
					map_nonzero_temp[x, z] = (avg != 0) ? true : false;
					colorMap.SetPixel(x,z,ColorFromHeight(avg, upperBound, lowerBound)); 
				}
			}
			Array.Copy (map_temp, map, map_temp.Length);
			Array.Copy (map_nonzero_temp, map_nonzero, map_nonzero_temp.Length);
		}
		colorMap.Apply(); 
		
		// Scale values back to original bounds:
		double minC = map.Cast<double>().Min(), maxC = map.Cast<double>().Max ();
		for(int x=0; x<cmapWidth; x++){
			for (int z=0; z<cmapHeight; z++){
				colorMap.SetPixel(x,z,ColorFromHeight(map[x, z], maxC, minC)); 
			}
		}
		
		colorMap.Apply(); 
		SaveColorToDisk(colorMap);
	}

	protected virtual UnityEngine.Color GrayscaleFromHeight(double height, double maxHeight, double minHeight) 
	{ 
		UnityEngine.Color color = new UnityEngine.Color(0,0,0,1);
		double scalar = (height-minHeight) / (maxHeight-minHeight);
		Int32 mColor = (Int32)Math.Floor(scalar * Math.Pow(2, 24));
		Int32 b = mColor%256;
		Int32 g = mColor%(256*256);
		g /= 256;
		Int32 r = mColor;
		r /= 256*256;
		color.r = (float)((float)r/256f);
		color.g = (float)((float)g/256f);
		color.b = (float)((float)b/256f);
		return color;
	}

	protected Color ColorFromHeight(double height, double maxHeight, double minHeight) 
	{ 
		double scalar = (height-minHeight) / (maxHeight-minHeight);
		Color val = spectrum.GetColorFromVal((float)scalar);
		return val;
	}
}