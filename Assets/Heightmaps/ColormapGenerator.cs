//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Drawing;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Linq;
using UnityEngine;
public class ColormapGenerator
{
	ColorSpectrumObj spectrum;
	
	protected Texture2D heightMap;
	protected double minX, minZ, maxX, maxZ;
	
	protected double lowerBound, upperBound;
	protected double maxRadius;
	protected String filename;

	private double bWidth, bHeight;
	
	public static int HILLS = 0;
	public static int PEAKS = 1;
	
	// Variables Holder
	Variables Vars;

	public ColormapGenerator (Variables Vars, String filename, double maxRadius,
	                          double minX, double minZ, double maxX, double maxZ, ColorSpectrumObj spectrum)
	{
		this.Vars = Vars;
		this.spectrum = spectrum;
		this.filename = filename;
		this.maxRadius = maxRadius;
		this.minX = minZ;
		this.minZ = maxX;
		this.maxX = maxZ;
		this.maxZ = minX;
	}
	
	/// <summary>
	/// Initializes a new instance of the <see cref="HeightmapGenerator"/> class.
	/// </summary>
	/// <param name="data">Data with each object containing the following structure: 
	/// [ peak_height, peak_X, peak_Y ]</param>
	/// <param name="tWidth">T width.</param>
	/// <param name="tHeight">T height.</param>
	/// <param name="maxRadius">Max radius.</param>
	/// 
	/*public HeightmapGenerator (List<double[]> data, int bitmapWidth, int bitmapHeight, double maxRadius)*/
	
	public virtual Texture2D GetHeightmap(double bWidth, double bHeight){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);
//		maxRadius = dataHandler.GetMaxRadius();

		this.bWidth = bWidth - (2*maxRadius*bWidth);
		this.bHeight = bHeight - (2*maxRadius*bHeight);
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = bnds[1];
		
		CreateHeightMap(dataHandler.GetData());
		SaveToDisk();
		return heightMap;
	}

	public virtual Texture2D GetHeightmapCylinder(double bWidth, double bHeight){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);
		//		maxRadius = dataHandler.GetMaxRadius();

		this.bWidth = bWidth - (2*maxRadius*bWidth);
		this.bHeight = bHeight - (2*maxRadius*bHeight);
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = bnds[1];
		
		CreateHeightMapCylinder(dataHandler.GetData());
		SaveToDisk();
		return heightMap;
	}

	public virtual Texture2D GetHeightmap(double bWidth, double bHeight, List<double[]> data, double lower, double upper){
		//		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);
		//		maxRadius = dataHandler.GetMaxRadius();

		this.bWidth = bWidth;// - (2*maxRadius*bWidth);
		this.bHeight = bHeight;// - (2*maxRadius*bHeight);
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		lowerBound = lower;//bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = upper;//bnds[1];
		
		CreateHeightMap(data);
		SaveToDisk();
		return heightMap;
	}

	public virtual Texture2D GetHeightmapCylinder(double bWidth, double bHeight, List<double[]> data, double lower, double upper){

		this.bWidth = bWidth;// - (2*maxRadius*bWidth);
		this.bHeight = bHeight;// - (2*maxRadius*bHeight);
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		lowerBound = lower;//bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds..this comment is unnecessary
		upperBound = upper;//bnds[1];
		
		CreateHeightMapCylinder(data);
		SaveToDisk();
		return heightMap;
	}
	
	protected void FillInColor(UnityEngine.Color c){
		for(int i = 0; i < heightMap.width; i++) {
			for(int j = 0; j < heightMap.height; j++) {
				heightMap.SetPixel(i,j, c);
			}
		}
	}
 
	public void SaveToDisk() {
		byte[] bytes = heightMap.EncodeToPNG();
		File.WriteAllBytes(Application.dataPath + "/Heightmaps/Images/colormap_" + Vars.TERRAIN_NAME + ".png", bytes);
	}
	
	/// <summary>
	/// Creates the height map. 
	/// </summary>
	/// <param name="data">Data with each object containing the following structure:  
	/// [ peak_height, peak_X, peak_Y ]
	/// </param>
	protected void CreateHeightMap(List<double[]> data){
		double it = (upperBound-lowerBound)/Vars.ITERATION_NUMBER;
		if(it == 0)
			it = 1f;
		double h = lowerBound;
		while(data.Count != 0){
			h += it;
			//for(double h=lowerBound; h<upperBound; h+= it){
			List<int> toRemove = new List<int>();
			for(int i=0; i<data.Count; i++){
				if(Math.Abs(data[i][1]) < h){
					toRemove.Add(i);
				}
				DrawHillRadius(data[i][1], data[i][0] * bWidth, data[i][2] * bHeight, (h/Math.Abs(data[i][1]))*data[i][1], maxRadius * bWidth, HILLS);
			}
			for(int i=0; i<toRemove.Count; i++){
				data.RemoveAt(toRemove[i]-i);
			}
		}
		heightMap.Apply();
	}

	protected void CreateHeightMapCylinder(List<double[]> data){
		double it = (upperBound-lowerBound)/Vars.ITERATION_NUMBER;
		if(it == 0)
			it = 1f;
		//double it = Vars.ITERATION_NUMBER;
		System.Drawing.Bitmap bit = new System.Drawing.Bitmap(heightMap.width, heightMap.height);
		System.Drawing.Graphics g = System.Drawing.Graphics.FromImage(bit);
		
		double h = lowerBound;
		while(data.Count != 0){
			h += it;
			//for(double h=lowerBound; h<upperBound; h+= it){
			List<int> toRemove = new List<int>();
			for(int i=0; i<data.Count; i++){
				if(Math.Abs(data[i][1]) < h){ //If middle of the values is less than the lower bounds, then add it "toRemove" List
					toRemove.Add(i);
					//					DrawHillRadius(data[i][1], data[i][0] * bWidth + (maxRadius*bWidth), data[i][2] * bHeight + (maxRadius*bWidth), h, maxRadius * bWidth, HILLS);
					//DrawHillRadius(data[i][1], data[i][0] * bWidth, data[i][2] * bHeight, h, maxRadius * bWidth, HILLS);
					double height = data[i][1];
					System.Drawing.Color col = ColourConvert(height);
					Brush brush = new SolidBrush(col);
					Rectangle rect = new Rectangle((int)(data[i][0] * bWidth) - 5, (int)(data[i][2] * bHeight) - 5, 10 , 10);
					g.FillEllipse(brush, rect);
				}
			}
			for(int i=0; i<toRemove.Count; i++){
				data.RemoveAt(toRemove[i]-i);
			}
		}
		bit.RotateFlip(RotateFlipType.Rotate180FlipX);
		ImageConverter imgconv = new ImageConverter();
		byte[] hmapbytes = (byte[])imgconv.ConvertTo(bit, typeof(byte[]));
		heightMap.LoadImage(hmapbytes);
		heightMap.Apply();
	}

	public void DrawHillRadius(double peak, double peakX, double peakY, double height, double maxRadius, int HillsOrPeaks)
	{
		Circle(ref heightMap, (int)peakX, (int)peakY, (int)RadiusFunc(peak, height, maxRadius), ColorFromHeight(height, upperBound, lowerBound));
	}
	
	protected UnityEngine.Color ColorFromHeight(double height, double maxHeight, double minHeight) 
	{ 
		double scalar = (height-minHeight) / (maxHeight-minHeight);
		UnityEngine.Color val = spectrum.GetColorFromVal((float)scalar);
		return val;
	}
	
	private double HeightFunc(double peak, double radius, double maxRadius)
	{
		double z = (radius/maxRadius) * (Math.PI*2);
		double y = (0.5)*Math.Cos(0.5*z) + 0.5;
		return y * peak;
	}
	
	private double RadiusFunc(double peak, double height, double maxRadius)
	{
		double cosVal = height/peak;
		double z = 2 * Math.Acos((2*cosVal) - 1);
		double radius = (z * maxRadius) / (Math.PI * 2);
		return radius;
	}

	public System.Drawing.Color ColourConvert(double val)
	{
		UnityEngine.Color unityC = ColorFromHeight(val, upperBound, lowerBound);
		UnityEngine.Color32 unicolour = new UnityEngine.Color(unityC.r, unityC.g, unityC.b, unityC.a);
		System.Drawing.Color wincolour = new System.Drawing.Color();
		wincolour = System.Drawing.Color.FromArgb(unicolour.a, unicolour.r, unicolour.g, unicolour.b);
		return wincolour;
	}
	
	public void Circle(ref Texture2D tex, int cx, int cy, int r, UnityEngine.Color col)
	{
		int x, y, px, nx, py, ny, d;
		
		for (x = 0; x <= r; x++)
		{
			d = (int)Mathf.Ceil(Mathf.Sqrt(r * r - x * x));
			for (y = 0; y <= d; y++)
			{
				px = cx + x;
				nx = cx - x;
				py = cy + y;
				ny = cy - y;
				
				if(px >= 0 && py >= 0 && px < tex.width && py < tex.height)
					tex.SetPixel(px, py, col);
				if(nx >= 0 && py >= 0 && nx < tex.width && py < tex.height)
					tex.SetPixel(nx, py, col);
				
				if(px >= 0 && ny >= 0 && px < tex.width && ny < tex.height)
					tex.SetPixel(px, ny, col);
				if(nx >= 0 && ny >= 0 && nx < tex.width && ny < tex.height)
					tex.SetPixel(nx, ny, col);
				
			}
		}
	}
}