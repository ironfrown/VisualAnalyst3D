//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Drawing;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Linq;
using UnityEngine;
public class ColormapGenerator
{
	ColorSpectrumObj spectrum;
	
	protected Texture2D heightMap;
	protected double minX, minZ, maxX, maxZ;
	
	protected double lowerBound, upperBound;
	protected double maxRadius;
	protected String filename;

	private double bWidth, bHeight;
	
	public static int HILLS = 0;
	public static int PEAKS = 1;
	
	// Variables Holder
	Variables Vars;

	/// <summary>
	/// Initializes a new instance of the <see cref="ColormapGenerator"/> class.
	/// </summary>
	/// <param name="Vars">Variables instance..</param>
	/// <param name="filename">Filename of the data to be parsed and used.</param>
	/// <param name="maxRadius">Max radius of hills to be generated on the terrain as a proportion of the max width of the image (0.0 - 1.0).</param>
	/// <param name="minX">Minimum X value of the data.</param>
	/// <param name="minZ">Minimum Z value of the data.</param>
	/// <param name="maxX">Max X value of the data.</param>
	/// <param name="maxZ">Max Z value of the data.</param>
	/// <param name="spectrum">Color spectrum object to be used as reference for the color at given heights of the terrain.</param>
	public ColormapGenerator (Variables Vars, String filename, double maxRadius,
	                          double minX, double minZ, double maxX, double maxZ, ColorSpectrumObj spectrum)
	{
		this.Vars = Vars;
		this.spectrum = spectrum;
		this.filename = filename;
		this.maxRadius = maxRadius;
		// Swapping X and Z values due to an inconsistency in the data layout.
		this.minX = minX;
		this.minZ = minZ;
		this.maxX = maxX;
		this.maxZ = maxZ;
//		this.minX = minZ;
//		this.minZ = maxX;
//		this.maxX = maxZ;
//		this.maxZ = minX;
	}

	/// <summary>
	/// Generates the colormap with inputs specified by the constructor.
	/// </summary>
	/// <returns>The colormap texture object.</returns>
	/// <param name="bWidth">Width of the colormap texture bitmap.</param>
	/// <param name="bHeight">Height of the colormap texture bitmap.</param>
	public virtual Texture2D GetHeightmap(double bWidth, double bHeight){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);

		this.bWidth = bWidth - (2*maxRadius*bWidth);
		this.bHeight = bHeight - (2*maxRadius*bHeight);
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds.
		upperBound = bnds[1];
		
		CreateHeightMap(dataHandler.GetData());
		SaveToDisk();
		return heightMap;
	}
	
	/// <summary>
	/// Generates the colormap with inputs specified by the constructor 
	/// with cylinders rather than hills as the terrain type.
	/// </summary>
	/// <returns>The colormap texture object.</returns>
	/// <param name="bWidth">Width of the colormap texture bitmap.</param>
	/// <param name="bHeight">Height of the colormap texture bitmap.</param>
	public virtual Texture2D GetHeightmapCylinder(double bWidth, double bHeight){
		DataHandler dataHandler = new DataHandler(filename, Vars.COLUMN_X, Vars.COLUMN_Y, Vars.COLUMN_Z, minX, minZ, maxX, maxZ);

		this.bWidth = bWidth - (2*maxRadius*bWidth);
		this.bHeight = bHeight - (2*maxRadius*bHeight);
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		double[] bnds= dataHandler.GetBounds();
		lowerBound = bnds[0] - ((bnds[1]-bnds[0]+1)/10.0d); // lower bound minus 10% of the difference between bounds.
		upperBound = bnds[1];
		
		CreateHeightMapCylinder(dataHandler.GetData());
		SaveToDisk();
		return heightMap;
	}

	/// <summary>
	/// Generates the colormap texture object with terrain type as hills.
	/// However this overload is used by the sex terrain generator since it offers
	/// additional options for the generation.
	/// </summary>
	/// <returns>The colormap texture.</returns>
	/// <param name="bWidth">Width of the colormap texture bitmap.</param>
	/// <param name="bHeight">Height of the colormap texture bitmap.</param>
	/// <param name="data">The data read by DataHandler.</param>
	/// <param name="lower">Lower bound of the data's Y value.</param>
	/// <param name="upper">Upper bound of the data's Y value.</param>
	public virtual Texture2D GetHeightmap(double bWidth, double bHeight, List<double[]> data, double lower, double upper){
		this.bWidth = bWidth;
		this.bHeight = bHeight;
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		lowerBound = lower;
		upperBound = upper;
		
		CreateHeightMap(data);
		SaveToDisk();
		return heightMap;
	}

	/// <summary>
	/// Generates the colormap with inputs specified by the constructor 
	/// with cylinders rather than hills as the terrain type. Also allowing
	/// a greater number of inputs to allow for changes to the data and bounds.
	/// </summary>
	/// <returns>The colormap texture.</returns>
	/// <param name="bWidth">Width of the colormap texture bitmap.</param>
	/// <param name="bHeight">Height of the colormap texture bitmap.</param>
	/// <param name="data">The data read by DataHandler.</param>
	/// <param name="lower">Lower bound of the data's Y value.</param>
	/// <param name="upper">Upper bound of the data's Y value.</param>
	public virtual Texture2D GetHeightmapCylinder(double bWidth, double bHeight, List<double[]> data, double lower, double upper){

		this.bWidth = bWidth;
		this.bHeight = bHeight;
		heightMap = new Texture2D((int)bWidth, (int)bHeight);
		FillInColor(UnityEngine.Color.black);
		
		lowerBound = lower;
		upperBound = upper;
		
		CreateHeightMapCylinder(data);
		SaveToDisk();
		return heightMap;
	}

	/// <summary>
	/// Fills the entire bitmap with a given color.
	/// </summary>
	/// <param name="c">Color with which to fill.</param>
	protected void FillInColor(UnityEngine.Color c){
		for(int i = 0; i < heightMap.width; i++) {
			for(int j = 0; j < heightMap.height; j++) {
				heightMap.SetPixel(i,j, c);
			}
		}
	}
 
	/// <summary>
	/// Saves bitmap texture to disk memory.
	/// </summary>
	public void SaveToDisk() {
		byte[] bytes = heightMap.EncodeToPNG();
		File.WriteAllBytes(Application.dataPath + "/Heightmaps/Images/colormap_" + Vars.TERRAIN_NAME + ".png", bytes);
	}
	
	/// <summary>
	/// Creates the height map. 
	/// </summary>
	/// <param name="data">Data with each object containing the following structure:  
	/// [ peak_height, peak_X, peak_Y ]
	/// </param>
	protected void CreateHeightMap(List<double[]> data){
		double it = (upperBound-lowerBound)/Vars.ITERATION_NUMBER;
		if(it == 0)
			it = 1f;
		double h = lowerBound;
		while(data.Count != 0){
			h += it;
			List<int> toRemove = new List<int>();
			for(int i=0; i<data.Count; i++){
				if(Math.Abs(data[i][1]) < h){
					toRemove.Add(i);
				}
				DrawHillRadius(data[i][1], data[i][0] * bWidth, data[i][2] * bHeight, (h/Math.Abs(data[i][1]))*data[i][1], maxRadius * bWidth, HILLS);
			}
			for(int i=0; i<toRemove.Count; i++){
				data.RemoveAt(toRemove[i]-i);
			}
		}
		heightMap.Apply();
	}

	/// <summary>
	/// Creates the height map with cylinders rather than hills
	/// </summary>
	/// <param name="data">Data with each object containing the following structure:  
	/// [ peak_height, peak_X, peak_Y ]
	/// </param>
	protected void CreateHeightMapCylinder(List<double[]> data){
		double it = (upperBound-lowerBound)/Vars.ITERATION_NUMBER;
		if(it == 0)
			it = 1f;
		System.Drawing.Bitmap bit = new System.Drawing.Bitmap(heightMap.width, heightMap.height);
		System.Drawing.Graphics g = System.Drawing.Graphics.FromImage(bit);
		
		double h = lowerBound;
		while(data.Count != 0){
			h += it;
			List<int> toRemove = new List<int>();
			for(int i=0; i<data.Count; i++){
				if(Math.Abs(data[i][1]) < h){ //If middle of the values is less than the lower bounds, then add it "toRemove" List
					toRemove.Add(i);
					double height = data[i][1];
					System.Drawing.Color col = ColourConvert(height);
					Brush brush = new SolidBrush(col);
					Rectangle rect = new Rectangle((int)(data[i][0] * bWidth) - 5, (int)(data[i][2] * bHeight) - 5, 10 , 10);
					g.FillEllipse(brush, rect);
				}
			}
			for(int i=0; i<toRemove.Count; i++){
				data.RemoveAt(toRemove[i]-i);
			}
		}
		bit.RotateFlip(RotateFlipType.Rotate180FlipX);
		ImageConverter imgconv = new ImageConverter();
		byte[] hmapbytes = (byte[])imgconv.ConvertTo(bit, typeof(byte[]));
		heightMap.LoadImage(hmapbytes);
		heightMap.Apply();
	}

	/// <summary>
	/// Draws a circle on the bitmap with given x and y coords
	/// as well as height to be input to <see cref="ColorFromHeight"/>
	/// and compared to maxRadius using <see cref="RadiusFunc"/>
	/// </summary>
	/// <param name="peak">Peak.</param>
	/// <param name="peakX">Peak x coord.</param>
	/// <param name="peakY">Peak y coord.</param>
	/// <param name="height">Height.</param>
	/// <param name="maxRadius">Max radius.</param>
	/// <param name="HillsOrPeaks">Hills or peaks REDUNDANT.</param>
	public void DrawHillRadius(double peak, double peakX, double peakY, double height, double maxRadius, int HillsOrPeaks)
	{
		Circle(ref heightMap, (int)peakX, (int)peakY, (int)RadiusFunc(peak, height, maxRadius), ColorFromHeight(height, upperBound, lowerBound));
	}

	/// <summary>
	/// Returns a color given a height within the range
	/// of the max and min possible heights according
	/// to the <see cref="ColorSpectrumObj"/> specified
	/// in the constructor.
	/// </summary>
	/// <returns>The color associated with the height.</returns>
	/// <param name="height">Height.</param>
	/// <param name="maxHeight">Max height.</param>
	/// <param name="minHeight">Minimum height.</param>
	protected UnityEngine.Color ColorFromHeight(double height, double maxHeight, double minHeight) 
	{ 
		double scalar = (height-minHeight) / (maxHeight-minHeight);
		UnityEngine.Color val = spectrum.GetColorFromVal((float)scalar);
		return val;
	}

	/// <summary>
	/// Returns the radius of the hill at the given height
	/// given the peak height of the hill (the Y value of the
	/// data point)
	/// </summary>
	/// <returns>The the radius of the hill at height given
	/// max height of data point is peak.</returns>
	/// <param name="peak">Peak height of data point.</param>
	/// <param name="height">Height at which to find radius.</param>
	/// <param name="maxRadius">Max radius.</param>
	private double RadiusFunc(double peak, double height, double maxRadius)
	{
		double cosVal = height/peak;
		double z = 2 * Math.Acos((2*cosVal) - 1);
		double radius = (z * maxRadius) / (Math.PI * 2);
		return radius;
	}

	/// <summary>
	/// Converts height of data point to
	/// System.Drawing.Color using <see cref="ColorSpectrum"/>
	/// </summary>
	/// <returns>The System.Drawing.Color object.</returns>
	/// <param name="val">Height of data point.</param>
	public System.Drawing.Color ColourConvert(double val)
	{
		UnityEngine.Color unityC = ColorFromHeight(val, upperBound, lowerBound);
		UnityEngine.Color32 unicolour = new UnityEngine.Color(unityC.r, unityC.g, unityC.b, unityC.a);
		System.Drawing.Color wincolour = new System.Drawing.Color();
		wincolour = System.Drawing.Color.FromArgb(unicolour.a, unicolour.r, unicolour.g, unicolour.b);
		return wincolour;
	}

	/// <summary>
	/// Draws a circle on the specified Texture2D
	/// </summary>
	/// <param name="tex">Texture on which to draw</param>
	/// <param name="cx">Centre of circle X coord.</param>
	/// <param name="cy">Centre of circle Y coord.</param>
	/// <param name="r">The radius of the circle.</param>
	/// <param name="col">Color of circle to draw.</param>
	public void Circle(ref Texture2D tex, int cx, int cy, int r, UnityEngine.Color col)
	{
		int x, y, px, nx, py, ny, d;
		
		for (x = 0; x <= r; x++)
		{
			d = (int)Mathf.Ceil(Mathf.Sqrt(r * r - x * x));
			for (y = 0; y <= d; y++)
			{
				px = cx + x;
				nx = cx - x;
				py = cy + y;
				ny = cy - y;
				
				if(px >= 0 && py >= 0 && px < tex.width && py < tex.height)
					tex.SetPixel(px, py, col);
				if(nx >= 0 && py >= 0 && nx < tex.width && py < tex.height)
					tex.SetPixel(nx, py, col);
				
				if(px >= 0 && ny >= 0 && px < tex.width && ny < tex.height)
					tex.SetPixel(px, ny, col);
				if(nx >= 0 && ny >= 0 && nx < tex.width && ny < tex.height)
					tex.SetPixel(nx, ny, col);
				
			}
		}
	}
}